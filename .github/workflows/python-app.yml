# This workflow will install Python dependencies, run tests and build the application
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python

name: Build and Test

on:
  push:
    branches: [ "main" ]
    tags: [ "v*" ]  # Also trigger on version tags
    paths:
      - '**.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - '.github/workflows/**'
  pull_request:
    branches: [ "main" ]
    paths:
      - '**.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - '.github/workflows/**'
  # Always allow manual triggering for releases
  workflow_dispatch:

permissions:
  contents: write

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      python-version: ${{ steps.setup-python.outputs.python-version }}
      cache-hit: ${{ steps.cached-poetry-dependencies.outputs.cache-hit }}
    
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      id: setup-python
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root --with dev

    - name: Install project
      run: poetry install --no-interaction --with dev

  test:
    runs-on: ubuntu-latest
    needs: setup

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-3.12-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies if cache miss
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --with dev

    - name: Lint with flake8
      run: |
        # Check for critical errors (syntax errors and undefined names)
        poetry run flake8 --select=E9,F63,F7,F82 --show-source --statistics
        # Full lint check with all configured rules
        poetry run flake8 --exit-zero --statistics

    - name: Test syntax compilation
      run: |
        poetry run python -m py_compile backup_config.py
        poetry run python -m py_compile backup_engine.py
        poetry run python -c "import backup_config; print('backup_config imports successfully')"
        poetry run python -c "import backup_engine; print('backup_engine imports successfully')"

    - name: Test GUI imports (headless)
      run: |
        # Test that GUI modules can be imported (without actually creating windows)
        export QT_QPA_PLATFORM=offscreen
        poetry run python -c "from PyQt5.QtWidgets import QApplication; print('PyQt5 imports successfully')"
        poetry run python -c "import gui.main_window; print('GUI modules import successfully')"

  check-release:
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      needs-release: ${{ steps.check-version.outputs.needs-release }}
      version: ${{ steps.get-version.outputs.version }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies-check
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-3.12-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies if cache miss
      if: steps.cached-poetry-dependencies-check.outputs.cache-hit != 'true'
      run: poetry install --no-interaction

    - name: Get version from pyproject.toml
      id: get-version
      run: |
        VERSION=$(poetry version --short)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Detected version: $VERSION"

    - name: Check if release exists
      id: check-version
      run: |
        VERSION="${{ steps.get-version.outputs.version }}"
        if gh release view "v$VERSION" >/dev/null 2>&1; then
          echo "needs-release=false" >> $GITHUB_OUTPUT
          echo "Release v$VERSION already exists - no build needed unless source files changed"
        else
          echo "needs-release=true" >> $GITHUB_OUTPUT
          echo "Release v$VERSION does not exist - will force build"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    runs-on: ubuntu-latest
    needs: [test, check-release]
    # Build if: 1) this is triggered by source file changes, OR 2) we need a new release
    if: github.event_name != 'push' || needs.check-release.outputs.needs-release == 'true'
    outputs:
      version: ${{ needs.check-release.outputs.version }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Install dependencies
      run: poetry install --no-interaction

    - name: Create version constant file
      run: |
        VERSION=${{ needs.check-release.outputs.version }}
        echo "CONCRETE_BACKUP_VERSION = \"${VERSION}\"" > version_const.py
        echo "Created version_const.py with version: ${VERSION}"

    - name: Build with PyInstaller
      run: |
        poetry run pyinstaller \
          --onefile \
          --name concrete-backup-bin \
          --hidden-import=PyQt5.QtCore \
          --hidden-import=PyQt5.QtGui \
          --hidden-import=PyQt5.QtWidgets \
          --add-data="icon.png:." \
          backup_gui.py

    - name: Make scripts executable
      run: chmod +x .github/scripts/*.sh

    - name: Create Debian package structure
      run: .github/scripts/create-deb-structure.sh "${{ needs.check-release.outputs.version }}" debian-package

    - name: Build Debian package
      run: .github/scripts/build-deb-package.sh "${{ needs.check-release.outputs.version }}"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: concrete-backup-${{ needs.check-release.outputs.version }}-deb
        path: concrete-backup_${{ needs.check-release.outputs.version }}-1_amd64.deb
        retention-days: 30

  release:
    runs-on: ubuntu-latest
    needs: [build, check-release]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')) && needs.check-release.outputs.needs-release == 'true'

    steps:
    - uses: actions/checkout@v4

    - name: Make scripts executable
      run: chmod +x .github/scripts/*.sh

    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        name: concrete-backup-${{ needs.check-release.outputs.version }}-deb
        path: artifacts/

    - name: List downloaded artifacts
      run: |
        echo "Downloaded artifacts:"
        find artifacts/ -type f -name "*.deb" | sort

    - name: Create release archive
      run: .github/scripts/create-release-archive.sh "${{ needs.check-release.outputs.version }}"

    - name: Check if release exists
      id: release_exists
      run: |
        VERSION="${{ needs.check-release.outputs.version }}"
        if gh release view "v$VERSION" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release v$VERSION already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Release v$VERSION does not exist"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create GitHub Release
      if: steps.release_exists.outputs.exists == 'false'
      run: .github/scripts/create-github-release.sh "${{ needs.check-release.outputs.version }}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
