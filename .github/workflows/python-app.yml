# This workflow will install Python dependencies, run tests and build the application
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python

name: Build and Test

on:
  push:
    branches: [ "main" ]
    tags: [ "v*" ]  # Also trigger on version tags
  pull_request:
    branches: [ "main" ]

permissions:
  contents: write

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      id: setup-python
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root --with dev

    - name: Install project
      run: poetry install --no-interaction --with dev

    - name: Lint with flake8
      run: |
        # Check for critical errors (syntax errors and undefined names)
        poetry run flake8 --select=E9,F63,F7,F82 --show-source --statistics
        # Full lint check with all configured rules
        poetry run flake8 --exit-zero --statistics

    - name: Test syntax compilation
      run: |
        poetry run python -m py_compile backup_config.py
        poetry run python -m py_compile backup_engine.py
        poetry run python -c "import backup_config; print('backup_config imports successfully')"
        poetry run python -c "import backup_engine; print('backup_engine imports successfully')"

    - name: Test GUI imports (headless)
      run: |
        # Test that GUI modules can be imported (without actually creating windows)
        export QT_QPA_PLATFORM=offscreen
        poetry run python -c "from PyQt5.QtWidgets import QApplication; print('PyQt5 imports successfully')"
        poetry run python -c "import gui.main_window; print('GUI modules import successfully')"

  build:
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.get-version.outputs.version }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Install dependencies
      run: poetry install --no-interaction --with dev

    - name: Get version from pyproject.toml
      id: get-version
      run: |
        VERSION=$(poetry version --short)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Detected version: $VERSION"

    - name: Install system dependencies for packaging
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential

    - name: Build executable with PyInstaller
      run: |
        export QT_QPA_PLATFORM=offscreen
        poetry run pyinstaller --onefile \
          --hidden-import=PyQt5 \
          --hidden-import=PyQt5.QtCore \
          --hidden-import=PyQt5.QtWidgets \
          --hidden-import=yaml \
          --hidden-import=psutil \
          --add-data "gui:gui" \
          --name concrete-backup-${{ steps.get-version.outputs.version }} \
          backup_gui.py

    - name: Test executable
      run: |
        # Test that the executable was created and is executable
        EXECUTABLE_NAME="concrete-backup-${{ steps.get-version.outputs.version }}"
        if [ -f "dist/$EXECUTABLE_NAME" ] && [ -x "dist/$EXECUTABLE_NAME" ]; then
          echo "✓ Executable created successfully and is executable"
          ls -la "dist/$EXECUTABLE_NAME"
          
          # Test basic command line options
          echo "Testing --help option..."
          "./dist/$EXECUTABLE_NAME" --help
          
          echo "Testing --version option..."
          "./dist/$EXECUTABLE_NAME" --version
          
          echo "Testing --headless-test option..."
          "./dist/$EXECUTABLE_NAME" --headless-test
        else
          echo "✗ Executable not found or not executable"
          exit 1
        fi

    - name: Upload executable artifact
      uses: actions/upload-artifact@v4
      with:
        name: concrete-backup-${{ steps.get-version.outputs.version }}-linux
        path: dist/concrete-backup-${{ steps.get-version.outputs.version }}
        retention-days: 30

    - name: Create application bundle
      run: |
        EXECUTABLE_NAME="concrete-backup-${{ steps.get-version.outputs.version }}"
        BUNDLE_NAME="concrete-backup-${{ steps.get-version.outputs.version }}-bundle"
        
        mkdir -p "$BUNDLE_NAME"
        cp "dist/$EXECUTABLE_NAME" "$BUNDLE_NAME/concrete-backup"
        cp run_backup_gui.sh "$BUNDLE_NAME/"
        cp README.md "$BUNDLE_NAME/"
        chmod +x "$BUNDLE_NAME/concrete-backup"
        chmod +x "$BUNDLE_NAME/run_backup_gui.sh"

    - name: Upload application bundle
      uses: actions/upload-artifact@v4
      with:
        name: concrete-backup-${{ steps.get-version.outputs.version }}-bundle-linux
        path: concrete-backup-${{ steps.get-version.outputs.version }}-bundle/
        retention-days: 30

  release:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v'))

    steps:
    - uses: actions/checkout@v4

    - name: Download executable artifact
      uses: actions/download-artifact@v4
      with:
        name: concrete-backup-${{ needs.build.outputs.version }}-linux
        path: artifacts/

    - name: Download bundle artifact
      uses: actions/download-artifact@v4
      with:
        name: concrete-backup-${{ needs.build.outputs.version }}-bundle-linux
        path: bundle-artifacts/

    - name: Create release archive
      run: |
        VERSION="${{ needs.build.outputs.version }}"
        
        # Create standalone executable archive
        mkdir -p release-files
        cp artifacts/concrete-backup-$VERSION release-files/
        cd release-files
        tar -czf concrete-backup-$VERSION-linux-x86_64.tar.gz concrete-backup-$VERSION
        cd ..
        
        # Create bundle archive
        cd bundle-artifacts
        tar -czf ../release-files/concrete-backup-$VERSION-bundle-linux-x86_64.tar.gz *
        cd ..

    - name: Check if release exists
      id: release_exists
      run: |
        VERSION="${{ needs.build.outputs.version }}"
        if gh release view "v$VERSION" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release v$VERSION already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Release v$VERSION does not exist"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create GitHub Release
      if: steps.release_exists.outputs.exists == 'false'
      run: |
        VERSION="${{ needs.build.outputs.version }}"
        
        # Create release notes
        cat > release-notes.md << EOF
        # Concrete Backup v$VERSION
        
        Automated release for version $VERSION.
        
        ## Downloads
        
        - **concrete-backup-$VERSION-linux-x86_64.tar.gz**: Standalone executable for Linux
        - **concrete-backup-$VERSION-bundle-linux-x86_64.tar.gz**: Complete bundle with executable, scripts, and documentation
        
        ## Installation
        
        1. Download the bundle archive
        2. Extract: \`tar -xzf concrete-backup-$VERSION-bundle-linux-x86_64.tar.gz\`
        3. Run: \`./run_backup_gui.sh\` or \`./concrete-backup\`
        
        ## System Requirements
        
        - Linux x86_64
        - No additional dependencies required (statically linked)
        EOF
        
        # Create the release
        gh release create "v$VERSION" \
          --title "Concrete Backup v$VERSION" \
          --notes-file release-notes.md \
          release-files/concrete-backup-$VERSION-linux-x86_64.tar.gz \
          release-files/concrete-backup-$VERSION-bundle-linux-x86_64.tar.gz
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
