name: Build and Release

on:
  # Build and release when a GitHub release is created manually
  release:
    types: [created]
  
  # Allow manual triggering for testing
  workflow_dispatch:

permissions:
  contents: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-3.12-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --with dev

    - name: Lint with flake8
      run: |
        # Check for critical errors (syntax errors and undefined names)
        poetry run flake8 --select=E9,F63,F7,F82 --show-source --statistics
        # Full lint check with all configured rules
        poetry run flake8 --exit-zero --statistics

    - name: Test syntax compilation
      run: |
        poetry run python -m py_compile backup_config.py
        poetry run python -m py_compile backup_engine.py
        poetry run python -c "import backup_config; print('backup_config imports successfully')"
        poetry run python -c "import backup_engine; print('backup_engine imports successfully')"

    - name: Test GUI imports (headless)
      run: |
        # Test that GUI modules can be imported (without actually creating windows)
        export QT_QPA_PLATFORM=offscreen
        poetry run python -c "from PyQt5.QtWidgets import QApplication; print('PyQt5 imports successfully')"
        poetry run python -c "import gui.main_window; print('GUI modules import successfully')"

  build:
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        include:
          - name: "Ubuntu/Debian (amd64)"
            arch: "amd64"
            format: "deb"
          - name: "Ubuntu/Debian (arm64)"
            arch: "arm64" 
            format: "deb"
          - name: "Generic Linux (x86_64)"
            arch: "x86_64"
            format: "tar.gz"
          - name: "Generic Linux (aarch64)"
            arch: "aarch64"
            format: "tar.gz"

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Install dependencies
      run: poetry install --no-interaction --with dev

    - name: Get version
      id: get-version
      run: |
        if [ "${{ github.event_name }}" = "release" ]; then
          VERSION="${{ github.event.release.tag_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix if present
        else
          VERSION=$(poetry version --short)
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Building version: $VERSION"

    - name: Create version constant file
      run: |
        VERSION=${{ steps.get-version.outputs.version }}
        echo "CONCRETE_BACKUP_VERSION = "${VERSION}"" > version_const.py

    - name: Build with PyInstaller
      run: |
        poetry run pyinstaller \
          --onefile \
          --name concrete-backup \
          --hidden-import=PyQt5.QtCore \
          --hidden-import=PyQt5.QtGui \
          --hidden-import=PyQt5.QtWidgets \
          --add-data="icon.png:." \
          backup_gui.py

    - name: Build Debian package
      if: matrix.format == 'deb'
      run: |
        VERSION=${{ steps.get-version.outputs.version }}
        ARCH=${{ matrix.arch }}
        
        # Create package structure
        mkdir -p concrete-backup_${VERSION}/DEBIAN
        mkdir -p concrete-backup_${VERSION}/usr/bin
        mkdir -p concrete-backup_${VERSION}/usr/share/applications
        mkdir -p concrete-backup_${VERSION}/usr/share/pixmaps
        
        # Copy binary
        cp dist/concrete-backup concrete-backup_${VERSION}/usr/bin/
        chmod +x concrete-backup_${VERSION}/usr/bin/concrete-backup
        
        # Copy icon
        cp icon.png concrete-backup_${VERSION}/usr/share/pixmaps/concrete-backup.png
        
        # Create desktop file
        cat > concrete-backup_${VERSION}/usr/share/applications/concrete-backup.desktop << EOF
        [Desktop Entry]
        Name=Concrete Backup
        Comment=A simple backup solution
        Exec=/usr/bin/concrete-backup
        Icon=concrete-backup
        Terminal=false
        Type=Application
        Categories=Utility;System;
        EOF
        
        # Create control file
        cat > concrete-backup_${VERSION}/DEBIAN/control << EOF
        Package: concrete-backup
        Version: ${VERSION}
        Section: utils
        Priority: optional
        Architecture: ${ARCH}
        Maintainer: wanjawischmeier
        Description: A simple backup solution
         Concrete Backup is a user-friendly backup application that helps you
         backup your important files and directories.
        EOF
        
        # Build package
        dpkg-deb --build concrete-backup_${VERSION}
        mv concrete-backup_${VERSION}.deb concrete-backup_${VERSION}-1_${ARCH}.deb

    - name: Create generic Linux archive
      if: matrix.format == 'tar.gz'
      run: |
        VERSION=${{ steps.get-version.outputs.version }}
        ARCH=${{ matrix.arch }}
        
        mkdir -p concrete-backup-${VERSION}-linux-${ARCH}
        cp dist/concrete-backup concrete-backup-${VERSION}-linux-${ARCH}/
        cp icon.png concrete-backup-${VERSION}-linux-${ARCH}/
        cp README.md concrete-backup-${VERSION}-linux-${ARCH}/
        
        # Create simple install script
        cat > concrete-backup-${VERSION}-linux-${ARCH}/install.sh << 'EOF'
        #!/bin/bash
        sudo cp concrete-backup /usr/local/bin/
        sudo chmod +x /usr/local/bin/concrete-backup
        echo "Concrete Backup installed to /usr/local/bin/concrete-backup"
        EOF
        chmod +x concrete-backup-${VERSION}-linux-${ARCH}/install.sh
        
        tar -czf concrete-backup-${VERSION}-linux-${ARCH}.tar.gz concrete-backup-${VERSION}-linux-${ARCH}/

    - name: Upload to release
      uses: softprops/action-gh-release@v1
      if: github.event_name == 'release'
      with:
        files: |
          *.deb
          *.tar.gz
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-snap:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    outputs:
      snap-file: ${{ steps.build-snap.outputs.snap }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Build Snap
      uses: snapcore/action-build@v1
      id: build-snap

    # Test that the snap is installable
    - name: Test snap installation
      run: |
        sudo snap install --dangerous ${{ steps.build-snap.outputs.snap }}
        # Test that the snap works
        echo "Snap installed successfully"

    - name: Upload snap to release
      uses: softprops/action-gh-release@v1
      if: github.event_name == 'release'
      with:
        files: ${{ steps.build-snap.outputs.snap }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-snap:
    runs-on: ubuntu-latest
    needs: [build-snap]
    if: github.event_name == 'release'
    steps:
    - name: Download snap artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build-snap.outputs.snap-file }}
        path: .

    - name: Publish to Snap Store
      uses: snapcore/action-publish@v1
      env:
        SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
      with:
        snap: ${{ needs.build-snap.outputs.snap-file }}
        release: stable
